# Экзамен по МВС

## Параллельная часть

1. First

2. Second

3. Third

4. Fourth

5. Fifth

6. Sixth

7. Seventh

8. Eighth

9. Ninth

10. Tenth

11. Eleventh

12. Twelfth

13. Thirteenth

14. Fourteenth

15. **Модель OpenMP программы. Переменные окружения используемые в OpenMP программах. Библиотечные функции. Сравнение с библиотекой pthread. Поддержка OpenMP со стороны компилятора, в том числе макросы выставляемые для OpenMP программ.**

    *OpenMP* - механизм написания параллельных программ для систем с общей памятью. Состоит за набора директив компилятора и библиотечных функций.  

      

    *Execution model:*

    * OpenMP API использует fork-join модель параллельного исполнения. Потоки исполняют задачи, явно или неявно определнные директивами OpenMP.
    * При старте OpenMP программы запускается один поток (initial thread). Он исполняется последовательно.
    * Потоки запускаются на host device. Возможна поддержка target device (каждый из них имеет свои потоки, миграция потоков между устройствами запрещена).
    * Потоки объединены в группы (teams).
    * При достижении директивы parallel порождается группа потоков, родительский поток также входит в эту группу потоков (master thread). С каждым потоком связывается задача, в которой выполняется код внутри директивы parallel. Задачи в разных потоках параллельно обрабатывают разные данные. После завершения всех потоков продолжает выполнение master thread. Для ожидания потоков используется барьер (неявно). Для того чтобы не ожидать завершения всех потоков можно использовать директиву nowait. Возможна поддержка вложенных директив parallel (nested parallelism).
    * Директива task позволяет создавать явные задачи, которые будут выполняться в одном из потоков текущей группы. Все задачи, созданные с помощью task завершаются до завершения потоков данной группы.
    * Также доступны директивы simd и cancel.

      

    *Memory model:*

    * Relaxed-consistency модель пямти - значение локальных копий могут различаться в разных потоках.
    * При создании потоков для переменной можно создать локальную копию для каждого потока (private). Private перменные используются только в текущем потоке, могут инициализироваться значением оригинальной переменной, результат может быть сохранен в оригинальной переменной. Shared переменные должны использоваться только на чтение, либо защищаться с помощью директив синхронизации.
    * Для синхронизации значения локальной копии переменной и переменной в памяти используется директива flush. Директива flush определяет место последнего изменения переменной и выполняет запись локального значения в память или чтение значения из памяти в локальную копию (при изменении значения в другом потоке). Программист должен обеспечить отсутствие конкурентной модификации переменной для которой выполняется flush.

      

    *Environment variables:*

    Ниже перечислены <u>некоторые</u> перменные окружения.

    * OMP_SCHEDULE:
      * Устанавливает тип распределения работ в параллельных циклах с типом runtime.
      * Синтаксис: setenv OMP_SCHEDULE "\<type\>[,chunk]"
      * types:
        1. static - блочно-циклическое распределение итераций цикла; размер блока - chunk. Первый блок из chunk итераций выполняет нулевой поток, второй блок - следующий и т.д. до последнего потока, затем распределение снова начинается с нулевого потока. Если значение chunk не указано, то все множество итераций делится на непрерывные куски примерно одинакового размера, и полученные порции итераций распределяются мужду потоками.
        2. dynamic - динамическое распределение итераций с фиксированным размером блока: сначала каждый поток получает chunk итераций, тот поток, который заканчивает выполнение своей порции итераций, получает первую свободную порцию из chunk итераций. Освободившиеся потоки получают новые порции итераций до тех пор, пока все порции не будут исчерпаны.
        3. guided - динамическое распределение итераций, при котором размер порции уменьшается с некоторого начального значения до велечины chunk пропорционально количеству еще не распределенных итераций, деленному на количество потоков, выполняющих цикл.
        4. auto - способ распределения итераций выбирается компилятором и/или системой выполнения.
    * OMP_NUM_THREADS
      * Задает количество потоков, выполняющих параллельные области программы.
      * setenv OMP_NUM_THREADS \<integer [list of integers]\>
    * OMP_DYNAMIC
      * Разрешает/запрещает динамически изменять количество потоков, используемых для выполнения параллельной области.
      * setenv OMP_DYNAMIC \<true/false\>
    * OMP_NESTED
      * Разрешает/запрещает вложенный параллелизм.
      * setenv OMP_NESTED \<true/false\>
    * OMP_STACKSIZE
      * Задает размер стека для создаваемых из программы потоков.
      * setenv OMP_STACKSIZE \<integer [B, K, M, G]\>
    * OMP_WAITPOLICY
      * Задает поведение ждущих процессов. Если задано значение ACTIVE, то ждущему процессу будут выдаваться циклы процессорного времени, а при значении PASSIVE ждущий процесс может быть отправлен в сппящий режим, при этом процессор может быть назначен дургим процессам.
      * setenv OMP_WAITPOLICY \<ACTIVE/PASSIVE\>
    * OMP_MAX_ACTIVE_LEVELS
      * Задает максимально допустимое количество вложенных параллельных областей.
      * setenv OMP_MAX_ACTIVE_LEVELS \<integer\>
    * OMP_THREAD_LIMIT
      *  Задает максимальное число потоков, допустимых в программе.
      * setenv OMP_THREAD_LIMIT \<integer\>

      

    *Runtime library routines:*

    Ниже перечислены <u>некоторые</u> библиотечные функции.

    * ```void omp_set_num_threads(int num_threads)```
      * Устанавливает количество потоков, которое может быть запрошено для параллельного блока.
    * ```int omp_get_num_threads()```
      * Возвращает количество потоков в текущей группе потоков.
    * ```int omp_get_max_threads()```
      * Возвращает максимальное количество потоков, которое может быть установлено omp_set_num_threads.
    * ```int omp_get_thread_num()```
      * Возвращает номер потока в группе.
    * ```int omp_get_num_procs()```
      * Возвращает количество физических процессоров, доступных программе.
    * ```int omp_in_parallel()```
      * Возвращает ненулевое значение, если вызвана внутри параллельного блока. В противном случае возвращается 0.
    * ```void omp_set_dynamic(int dynamic_threads)```
      * Разрешает/запрещает динамическое выделение потоков.
    * ```int omp_get_dynamic()```
      * Возвращает разрешено или запрещено динамическое выделение потоков.
    * ```void omp_set_nested(int nested)```
      * Разрешает/запрещает вложенный параллелизм.
    * ```int omp_get_nested()```
      * Возвращает разрешен или запрещен вложенный параллелизм.

      

    OpenMP поддерживается многими современными компиляторами:

    * Компиляторы Sun Studio
    * Visual C++
    * GCC
    * Intel C++ Compiler
    * Clang/llvm

    Компилятор с поддержкой OpenMP определяет макрос _OPENMP, который может использоваться для условной компиляции отдельных блоков, характерных для параллельной версии программы. Этот макрос определен в формате **yyyymm**, где **yyyy** и **mm** - цифры года и месяца, когда был принят поддерживаемый стандарт OpenMP.

16. Sixteenth

17. Seventeenth

18. Eighteenth

## Распределенная часть

