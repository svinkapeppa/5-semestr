# Экзамен по МВС

## Параллельная часть

1. First

2. Second

3. Third

4. Fourth

5. Fifth

6. Sixth

7. Seventh

8. Eighth

9. Ninth

10. Tenth

11. Eleventh

12. Twelfth

13. Thirteenth

14. Fourteenth

15. **Модель OpenMP программы. Переменные окружения используемые в OpenMP программах. Библиотечные функции. Сравнение с библиотекой pthread. Поддержка OpenMP со стороны компилятора, в том числе макросы выставляемые для OpenMP программ.**

    *OpenMP* - механизм написания параллельных программ для систем с общей памятью. Состоит за набора директив компилятора и библиотечных функций.  

      

    *Execution model:*

    * OpenMP API использует fork-join модель параллельного исполнения. Потоки исполняют задачи, явно или неявно определнные директивами OpenMP.
    * При старте OpenMP программы запускается один поток (initial thread). Он исполняется последовательно.
    * Потоки запускаются на host device. Возможна поддержка target device (каждый из них имеет свои потоки, миграция потоков между устройствами запрещена).
    * Потоки объединены в группы (teams).
    * При достижении директивы parallel порождается группа потоков, родительский поток также входит в эту группу потоков (master thread). С каждым потоком связывается задача, в которой выполняется код внутри директивы parallel. Задачи в разных потоках параллельно обрабатывают разные данные. После завершения всех потоков продолжает выполнение master thread. Для ожидания потоков используется барьер (неявно). Для того чтобы не ожидать завершения всех потоков можно использовать директиву nowait. Возможна поддержка вложенных директив parallel (nested parallelism).
    * Директива task позволяет создавать явные задачи, которые будут выполняться в одном из потоков текущей группы. Все задачи, созданные с помощью task завершаются до завершения потоков данной группы.
    * Также доступны директивы simd и cancel.

      

    *Memory model:*

    * Relaxed-consistency модель пямти - значение локальных копий могут различаться в разных потоках.
    * При создании потоков для переменной можно создать локальную копию для каждого потока (private). Private перменные используются только в текущем потоке, могут инициализироваться значением оригинальной переменной, результат может быть сохранен в оригинальной переменной. Shared переменные должны использоваться только на чтение, либо защищаться с помощью директив синхронизации.
    * Для синхронизации значения локальной копии переменной и переменной в памяти используется директива flush. Директива flush определяет место последнего изменения переменной и выполняет запись локального значения в память или чтение значения из памяти в локальную копию (при изменении значения в другом потоке). Программист должен обеспечить отсутствие конкурентной модификации переменной для которой выполняется flush.

      

    *Environment variables:*

    Ниже перечислены <u>некоторые</u> перменные окружения.

    * OMP_SCHEDULE:
      * Устанавливает тип распределения работ в параллельных циклах с типом runtime.
      * Синтаксис: setenv OMP_SCHEDULE "\<type\>[,chunk]"
      * types:
        1. static - блочно-циклическое распределение итераций цикла; размер блока - chunk. Первый блок из chunk итераций выполняет нулевой поток, второй блок - следующий и т.д. до последнего потока, затем распределение снова начинается с нулевого потока. Если значение chunk не указано, то все множество итераций делится на непрерывные куски примерно одинакового размера, и полученные порции итераций распределяются мужду потоками.
        2. dynamic - динамическое распределение итераций с фиксированным размером блока: сначала каждый поток получает chunk итераций, тот поток, который заканчивает выполнение своей порции итераций, получает первую свободную порцию из chunk итераций. Освободившиеся потоки получают новые порции итераций до тех пор, пока все порции не будут исчерпаны.
        3. guided - динамическое распределение итераций, при котором размер порции уменьшается с некоторого начального значения до велечины chunk пропорционально количеству еще не распределенных итераций, деленному на количество потоков, выполняющих цикл.
        4. auto - способ распределения итераций выбирается компилятором и/или системой выполнения.
    * OMP_NUM_THREADS
      * Задает количество потоков, выполняющих параллельные области программы.
      * setenv OMP_NUM_THREADS \<integer [list of integers]\>
    * OMP_DYNAMIC
      * Разрешает/запрещает динамически изменять количество потоков, используемых для выполнения параллельной области.
      * setenv OMP_DYNAMIC \<true/false\>
    * OMP_NESTED
      * Разрешает/запрещает вложенный параллелизм.
      * setenv OMP_NESTED \<true/false\>
    * OMP_STACKSIZE
      * Задает размер стека для создаваемых из программы потоков.
      * setenv OMP_STACKSIZE \<integer [B, K, M, G]\>
    * OMP_WAITPOLICY
      * Задает поведение ждущих процессов. Если задано значение ACTIVE, то ждущему процессу будут выдаваться циклы процессорного времени, а при значении PASSIVE ждущий процесс может быть отправлен в сппящий режим, при этом процессор может быть назначен дургим процессам.
      * setenv OMP_WAITPOLICY \<ACTIVE/PASSIVE\>
    * OMP_MAX_ACTIVE_LEVELS
      * Задает максимально допустимое количество вложенных параллельных областей.
      * setenv OMP_MAX_ACTIVE_LEVELS \<integer\>
    * OMP_THREAD_LIMIT
      *  Задает максимальное число потоков, допустимых в программе.
      * setenv OMP_THREAD_LIMIT \<integer\>

      

    *Runtime library routines:*

    Ниже перечислены <u>некоторые</u> библиотечные функции.

    * ```void omp_set_num_threads(int num_threads)```
      * Устанавливает количество потоков, которое может быть запрошено для параллельного блока.
    * ```int omp_get_num_threads()```
      * Возвращает количество потоков в текущей группе потоков.
    * ```int omp_get_max_threads()```
      * Возвращает максимальное количество потоков, которое может быть установлено omp_set_num_threads.
    * ```int omp_get_thread_num()```
      * Возвращает номер потока в группе.
    * ```int omp_get_num_procs()```
      * Возвращает количество физических процессоров, доступных программе.
    * ```int omp_in_parallel()```
      * Возвращает ненулевое значение, если вызвана внутри параллельного блока. В противном случае возвращается 0.
    * ```void omp_set_dynamic(int dynamic_threads)```
      * Разрешает/запрещает динамическое выделение потоков.
    * ```int omp_get_dynamic()```
      * Возвращает разрешено или запрещено динамическое выделение потоков.
    * ```void omp_set_nested(int nested)```
      * Разрешает/запрещает вложенный параллелизм.
    * ```int omp_get_nested()```
      * Возвращает разрешен или запрещен вложенный параллелизм.

      

    OpenMP поддерживается многими современными компиляторами:

    * Компиляторы Sun Studio
    * Visual C++
    * GCC
    * Intel C++ Compiler
    * Clang/llvm

    Компилятор с поддержкой OpenMP определяет макрос _OPENMP, который может использоваться для условной компиляции отдельных блоков, характерных для параллельной версии программы. Этот макрос определен в формате **yyyymm**, где **yyyy** и **mm** - цифры года и месяца, когда был принят поддерживаемый стандарт OpenMP.

16. **Параллельная секция в OpenMP. Параметры, указываемые при создании параллельной секции. Режимы инициализации и сохранения приватных переменных в параллельной секции. Методы разделения кода для исполнения разными потоками в OpenMP: sections, single, master, task.**

    *Параллельные области* являются основным понятием в OpenMP. Именно там, где задана эта область, программа исполняется параллельно. Как только компилятор встречает ```#pragma omp parallel```, он вставляет инструкции для создания параллельных потоков.

    Более подробно модель исполнения описана в ```15```.

    Синтаксис:

    ```
    #pragma omp parallel [clause[ [ , ] clause] ... ]
      structured-block
    ```

    где ```clause``` это:

    * ```if(scalar-expression)``` - выполнение параллельной области по условию. Вхождение в параллельную область осуществляется только при выполнении некоторого условия. Если условие не выполнено, то директива не срабатывает и продолжается обработка программы в прежнем режиме.
    * ```num_threads(integer-expression)``` - явное задание количества потоков, которые будут выполнять параллельную область; по умолчанию выбирается последнее значение, установленное  помощью функции *omp_set_num_threads(), или значение переменной OMP_NUM_THREADS.
    * ```default(shared | none)``` - всем переменным в параллельной области, которым явно не назначен класс, будет назначен класс *shared*; *none* означает, что всем переменным в параллельной области класс должен быть назначен явно. 
    * ```private(list)``` - задает список переменных, для которых порождается локальная копия в каждом потоке; начальное значение локальных копий переменных из списка не определено.
    * ```firstprivate(list)``` - задает список переменных, для которых порождается локальная копия в каждом потоке; локальные копии переменных инициализируются значениями этих переменных в потоке-мастере.
    * ```shared(list)``` - задает список переменных, общий для всех потоков.
    * ```copyin(list)``` - задает список переменных, объявленных как *threadprivate*, которые при входе в параллельную область инициализируются значениями соответствующих переменных в потоке-мастере.
    * ```reduction(reduction-identifier : list)``` - задает оператор и список общих переменных; для каждой переменной создаются локальные копии в каждом потоке; локальные копии инициализируются соответственно типу оператора; над локальными копиями перменных после завершения всех секций выполняется заданный оператор.
    * ```proc_bind(master | close | spread)``` - определяет способ привязки потоков в параллельной области.

      

    *sections*

    Директива *sections* используется для задания конечного (неитеративного) параллелизма. Эта директива определяет набор независимых секций кода, каждая из которых выполняется своим потоком.

    Директива *section* задает участок кода внутри секции *sections* для выполнения одним потоком.

    Синтаксис:

    ```
    #pragma omp sections [clause[ [ , ] clause] ... ]
      {
          [#pragma omp section]
            structured-block
          [#pragma omp section]
            structured-block
          ...
      }
    ```

    где ```clause``` это:

    * ```private(list)``` - задает список переменных, для которых порождается локальная копия в каждом потоке; начальное значение локальных копий переменных из списка не определено.
    * ```firstprivate(list)``` - задает список переменных, для которых порождается локальная копия в каждом потоке; локальные копии переменных инициализируются значениями этих переменных в потоке-мастере.
    * ```lastprivate(list)``` - переменным, перечисленным в списке, присваивается результат, полученный в последней секции.
    * ```reduction(reduction-identifier : list)``` - задает оператор и список общих переменных; для каждой переменной создаются локальные копии в каждом потоке; локальные копии инициализируются соответственно типу оператора; над локальными копиями перменных после завершения всех секций выполняется заданный оператор.
    * ```nowait``` - после выполнения выделенного участка происходит неявная барьерная синхронизация параллельно работающих потоков: их дальнейшее выполнение происходит только тогда, когда все они достигнут данной точки; если в подобной задержке нет необходимости, опция *nowait* позволяет потокам, уже дошедшим до конца участка, продолжить выполнение без синхронизации с остальными.

      

    *single*

    Директива *single* используется, если в параллельной области какой-либо участок кода должен быть выполнен лишь один раз.

    Синтаксис:

    ```
    #pragma omp single [clause[ [ , ] clause] ... ]
      structured-block
    ```

    где ```clause``` это:

    * ```private(list)``` - задает список переменных, для которых порождается локальная копия в каждом потоке; начальное значение локальных копий переменных из списка не определено.
    * ```firstprivate(list)``` - задает список переменных, для которых порождается локальная копия в каждом потоке; локальные копии переменных инициализируются значениями этих переменных в потоке-мастере.
    * ```copyprivate(list)``` - после выполнения потока, содержащего конструкцию *single*, новые значения переменных списка будут доступны всем одноименным частным переменным, описанным в начале параллельной области и используемым всеми ее потоками; опция не может использоваться совместно с опцией *nowait*; переменные списка не должны быть перечислены в опциях *private* и *firstprivate* данной директивы *single*.
    * ```nowait``` - после выполнения выделенного участка происходит неявная барьерная синхронизация параллельно работающих потоков: их дальнейшее выполнение происходит только тогда, когда все они достигнут данной точки; если в подобной задержке нет необходимости, опция *nowait* позволяет потокам, уже дошедшим до конца участка, продолжить выполнение без синхронизации с остальными.

      

    *master*

    Директива *master* выделяет участок кода, который будет выполнен только потоком-мастером.

    Синтаксис:

    ```
    #pragma omp master
      structured block
    ```

      

    *task*

    Директива *task* применяется для выделения отдельной независимой задачи.

    Синтаксис:

    ```
    #pragma omp task [clause[ [ , ] clause] ... ]
      structured block
    ```

    где ```clause``` это:

    * ```if(scalar-expression)``` - порождение новой задачи только при выполнении некоторого условия; если условие не выполняется, то задача будет выполнена текущим потоком немедленно.
    * ```final(scalar-expression)``` - если верно *scalar-expression*, то у задачи нет предков и она помещается в общий пул; ее потомки будут или *final task*, или *included task* (задача начнет выполняться потоком немедленно).
    * ```untied``` - опция означает, что в случае откладывания задача может быть продолжена любым потоком из числа выполняющих данную параллельную область; если данная опция не указана, то задача может быть продолжена только породившим ее потоком.
    * ```default(shared | none)``` - всем переменным в задаче, которым явно не назначен класс, будет назначен класс shared; none означает, что всем переменным в задаче класс должен быть назначен явно.
    * ```mergeable``` - задача имеет ту же среду данных, что и область, в которой она была сгенерирована.
    * ```private(list)```- задает список переменных, для которых порождается локальная копия в каждом потоке; начальное значение локальных копий переменных из списка не определено.
    * ```firstprivate(list)``` - задает список переменных, для которых порождается локальная копия в каждом потоке; локальные копии переменных инициализируются значениями этих перменных в потоке-мастере.
    * ```shared(list)``` - задает список переменных, общий для всех потоков.
    * ```depend(dependence-type : list)``` - в зависимости от *dependence-type* и того, что перечислено в *list* будут добавлены дополнительные ограничения на порядок выполнения задачи. 
    * ```priority(priority-value)``` - среди всех задач, готовых к выполнению, будут выбираться задачи с более высоким значением *priority-value*.

17. **Работа с циклами в OpenMP, указываемые параметры при создании. Параметр задающий расписание исполнения итераций. Параметр задающий распределеннную операцию.**

    Если в параллельной области встретился оператор цикла, то он будет выполнен всеми потоками текущей группы, то есть каждый поток выполнит все итерации данного цикла. Для распределения итераций цикла между различными потоками можно использовать директиву ```#pragma omp for```.

    Синтаксис:

    ```
    #pragma omp for [clause [ [ , ] clause] ... ]
      for-loops
    ```

    где ```clause``` это:

    * ```private(list)``` - задает список переменных, для которых порождается локальная копия в каждом потоке; начальное значение локальных копий переменных из списка не определено.
    * ```firstprivate(list)``` - задает список переменных, для которых порождается локальная копия в каждом потоке; локальные копии переменных инициализируются значениями этих перменных в потоке-мастере.
    * ```lastprivate(list)``` - переменным, перечисленным в списке, присваивается результат, полученный в последней итерации цикла.
    * ```linear(list [ : linear-step])``` - переменные, перечисленные в списке, будут *private* в соответсвтующем *SIMD lane* и будут линейно зависимы в пространстве итераций цикла.
    * ```reduction(reduction-identifier : list)``` - задает оператор и список общих переменных; для каждой переменной создаются локальные копии в каждом потоке; локальные копии инициализируются соответственно типу оператора; над локальными копиями перменных после завершения всех секций выполняется заданный оператор.
    * ```schedule(kind [, chunk_size])``` - опция задает, каким образом итерации цикла распределеяются между потоками (более подробно в ```15```).
    * ```collapse(n)``` - опция указывает, что *n* последовательных тесновложенных циклов ассоциируются с данной директивой; для циклов образуется общее пространство итераций, которое делится между потоками; если опция *collapse* не задана, то директива относится только к одному непосредственно следующему за ней циклу.
    * ```ordered``` - опция, говорящяя о том, что в цикле могут встречаться директивы *ordered*; в этом случае определяется блок внутри тела цикла, который должен выполняться в том порядке, в котором итерации идут в последовательном цикле.
    * ```nowait``` - в конце параллельного цикла происходит неявная барьерная синхронизация параллельно работающих потоков: их дальнейшее выполнение происходит только тогда, когда все они достигнут данной точки; если в подобной задержке нет необходимости, опция *nowait* позволяет потокам, уже дошедшим до конца цикла, продолжить выполнение без синхронизации с остальными.

18. Eighteenth

## Распределенная часть

